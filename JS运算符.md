# 运算符
- 算术运算符
- 比较运算符
- 布尔值运算符
- 二进制位运算符
- 其他运算符，运算顺序

# 算术运算符
运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。

## 1. 概述
JavaScript 共提供了10个算术运算符，用来完成基本的算术运算。

- 加法运算符： `x + y`
- 减法运算符： `x - y`
- 加法运算符： `x + y`
- 减法运算符： `x - y`
- 乘法运算符： `x * y`
- 除法运算符： `x / y`
- 指数运算符： `x ** y`
- 余数运算符： `x % y`
- 自增运算符： `++x` 或者 `x++`
- 自减运算符： `--x` 或者 `x--`
- 数值运算符： `+x`
- 负数值运算符: `-x`

减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。重点是加法运算符。

## 2. 加法运算符
### 2.1 基本规则

加法运算符（ `+` ）是最常见的运算符，用来求两个数值的和。
```
1 + 1       // 2
```

JavaScript允许非数值的相加。
```
true + true         // 2
1 + true            // 2
```

比較特殊的是，如果兩個字符串相加，這時加法運算符會變成連接運算符，返回一個新的字符串，將兩個原字符串連接在一起。
```
'a' + 'bc'      // "abc"
```

如果一個雲算子是字符串，另一個運算子是非字符串，這時字符串會轉成字符串，再連接在一起。
```
1 + 'a'     // "1a"

false + 'a'     // "falsea"
```

加法運算符是在運行時決定，到底是執行相加，還是執行連接。也就是說，運算子的不同，導致了不同的語法行爲，這種現象稱之爲“重載”（overload)。由於加法運算符存在重載，可能執行兩種運算，使用的時候必須很小心。
```
'1' + 2 + 3 + '4'       // "1234"

1 + 2 + 3 + '4'         // "64"
```
上面代碼中，由於從左到右的運算次序，字符串的位置不同會導致不同的結果。

除了加法運算符，其他運算符（減、乘、除）都不會發生重載。它們的規則是：所有運算子一律轉爲數值，在進行相應的數學運算。
```
1 - '2'     // -1

1 * '2'     // 2

1 / '2'     // 0.5
```

# 比較運算符
## 1. 概述
比較運算符用於比較兩個值的大小，然後返回一個布爾值，表示是否滿足指定的條件。

javascript 一共提供了8個比較運算符

- `>`   大於運算符
- `<`   小於運算符
- `<=`  小於或等於運算符
- `>=`  大於或等於運算符
- `==`  相等運算符
- `===` 嚴格相等運算符
- `!=`  不相等運算符
- `!==` 嚴格不相等運算符

這八個比較運算符分成兩類：相等比較和不相等比較。兩者的規則是不一樣的，對於非相等的比較，算法是先看兩個運算子是否都是字符串，如果是的，就按照字典順序比較（實際上是比較 Unicode 碼點），否則，將兩個運算子都轉成數值，再比較數值的大小。

## 非相等運算符：非字符串的比較
如果兩個運算子之中，至少有一個不是字符串，需要分成一下兩種情況。

1. 原始類型值
如果兩個運算子都是原始類型的值，則是先轉成數值再比較。

```
5 > '4'     // true
// 等同於 5 > Number('4')
// 即 5 > 4
```

2. 對象
如果運算子是對象，會轉爲原始類型的值，再進行比較

對象轉換成原始類型的值，算法是先調用 `valueOf` 方法；如果返回的還是對象，再接着調用 `toString` 方法。

## 嚴格相等運算符

JavaScript 提供了兩種相等運算符： `==` and `===`

簡單說：他們的區別是相等運算符（`==`）比較兩個值是否相等；嚴格相等運算符（`===`）比較它們是否爲同一個值。
如果兩個值不是同一類型，嚴格相等運算符（`===`）直接返回 `false` ,而相等運算符（`==`）會將它們轉換成同一個類型，再用嚴格相等運算符進行比較。

<b style="color:red;">
需要注意的是：NaN與任何值都不相等（包括自身）。  

另外正 `0` 等於負 `  `0`
</b>

```
NaN === NaN         // false

+0 === -0           // true
```

### 複合類型值
兩個複合類型（對象、數組、函數）的數據比較時，不是比較它們的值是否相等，而是比較它們是否指向同一個地址。

```
{} === {}       // false

[] === []       // fasle

(function () {} === function () {} )    // false
```

上面代碼分別比較兩個空對象、兩個空數組、兩個空函數，結果都是不相等。原因是對於複合類型的值，嚴格相等運算比較的是，它們是夠引用同一個內存地址，而運算符兩邊的空對象、空數組、控函數的值，都存放在不同的內存地址，結果當然是 `false`。

如果兩個變量引用同一個對象，則它們相等。
```
let v1 = {};
let v2 = v1;

v1 === v2       // true
```
<b style="color:red;">
注意：對於兩個對象的比較，嚴格相等運算符比較的是地址，而大於或小於運算符比較的是值。
</b>

```
let obj1 = {};
let obj2 = {};

obj1 > obj2     // false
obj1 < obj2     // false
obj1 === obj2   // false
```
上面的三個比較，前兩個比較的是值，最後一個比較的是地址，所以都返回 `false`。

### undefined And null

`undefined` 和 `null` 與自身嚴格相等。
```
undefined === undefined     // true
null === null       //true
```

由於變量聲明後默認值是 `undefined`,因此兩個只聲明爲賦值的變量是相等的。
```
let v1,v2;

v1 === v2       // true
```

`undefined` 和 `null` 與其他類型的值作比較時，結果都爲 `false`，它們相互比較時結果爲 `true`
```
false == null       // false
false == undefined  // false

0 == null       // false
0 == undefined  // false

undefined == null   // true
```

<b style="color:red;">
建議： 不要經常使用相等運算符（`==`），最好使用嚴格相等運算符（`===`）
</b>

### 不相等運算符
相等運算符有一個對應的 “不相等運算符”（`!=`），它的算法就是先求相等運算符的結果，然後返回相反值。
```
1 != '1'        // false
// 等同於
!(1 == '1')
```

# 布爾運算符
## 概述
布爾運算符用於將表達式轉爲布爾值，一共包含四個運算符。
- 取反運算符： `!`
- 且運算符： `&&`
- 或運算符： `||`
- 三元運算符： `?:`