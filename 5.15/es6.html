<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ES6</title>
</head>
<body>


<script type="text/html">
    /*    {
    var a = 10;
    let b = 100;
    alert(b);
    }*/

    var temp = new Date();

    function foo() {
    console.log(temp);
    if (false) {
    var temp = 'Hello World';
    // console.log(temp);
    }
    }
    foo();
    // 变量提升，导致内部temp 变量覆盖了外部的变量。
</script>

<script type="text/html">
    var tmp = new Date();

    function f() {
    console.log(tmp);
    if (false) {
    let tmp = 'hello world';
    }
    }

    f();
</script>

<script type="text/html">
    function f() {
    let a = 10;
    if (true) {
    let a = 5;
    //    console.log(a);     // 5
    }
    console.log(a);         // 10
    }

    f();
    //    函数的两个代码块，都声明了变量a，最后输出10；表示外部的代码不受内部代码的影响。
    //    如果都用 var 声明，输出就是5；
</script>

<script type="text/html">
    /*    let [a,...c] = [1,2,3];
    /!*    if (a + b > 2) {
    alert(c);
    }*!/
    console.log(a);
    console.log(c);*/

    let [a,b,c] = [1,2];
    console.log(a);
    console.log(b);
    console.log(c);
</script>

<script type="text/html">
    let {floor,pow} = Math;
    let a = 1.9;
    console.log(pow(2,3));
</script>

<script type="text/html">
    let a = 0;
    console.log(a);
</script>

<script type="text/html">

    let s = 'Hello';

    for (let i = 0; i < s.length; i++) {
        console.log(s[i]);
    }

    console.log(i);

    /*
    *
    * 此处如果用 var 的话，console.log(i); 可以被执行。泄漏变量，不安全。
    *
    * let 不可以被执行。
    *
    * */

</script>

<script type="text/html">
    function f() {
        let n = 5;
        if (true) {
            let n = 10;
        }
        console.log(n);
    }
    f();
    /*
    *
    * 此处打印 'n' 的值为 5 ；let 只在当前的作用域内有效。
    * 如果用 var 的话，打印的值就是 10 ；
    * */
</script>

<script type="text/html">
    {
        {
            {
                {
                    {
                        let i = "Hello World";
                        console.log(i);            // 可以执行。 let 只在当前作用域有效
                    }
                    console.log(i);             // 报错。 i is not defined；        i 未定义;
                }
            }
        }
    }

    /*
    *
    * ES6 允许块级作用域任意嵌套，
    * 不论嵌套多少层，外层作用域无法读取内层作用域的变量。
    *
    * */
</script>

<script type="text/html">
    function f() {
        var i = 0;
        return function () {
            console .log(++i);
        };
    }

    var counter = f();
    counter();
    counter();

    var counter2 = f();
    counter2();
    counter2();

    console.log(i);
</script>

<script>
    let [a,[b],c] = [1,[2],3];

    console.log(a,b,c);         // 1 2 3
    console.log(a);             // 1
    console.log(b);             // 2
    console.log(c);             // 3

    /*
    * 上面的代码表示，可以从数组中提取值，按照对应的位置，对变量赋值。
    *
    * 本质上，这种写法属于“ 模式匹配 ”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
    *
    * */

    let [x,y,...z] = ['a'];

    console.log(x);
    console.log(y);
    console.log(z);
</script>

</body>
</html>